#!/bin/env python
# -*- coding: utf-8 -*-
import os
import sys
import codecs
import re
import urllib3
from urllib3 import util
sys.path.append('../../')
from util import Utilty

# Type of printing.
OK = 'ok'         # [*]
NOTE = 'note'     # [+]
FAIL = 'fail'     # [-]
WARNING = 'warn'  # [!]
NONE = 'none'     # No label.


# Classifier class.
class ClassifierSignature:
    def __init__(self):
        self.full_path = os.path.dirname(os.path.abspath(__file__))
        self.signature_path = os.path.join(self.full_path, 'signature')
        self.util = Utilty()

    # Identify product name.
    def identify_product(self, categoy, response):
        prod_info_list = []
        file_name = 'signature_' + categoy + '.txt'
        try:
            # Judge product using pattern matching.
            with codecs.open(os.path.join(self.signature_path, file_name), 'r', 'utf-8') as fin:
                matching_patterns = fin.readlines()
                for pattern in matching_patterns:
                    items = pattern.replace('\r', '').replace('\n', '').split('@')
                    product = items[0]
                    signature = items[2]
                    list_match = re.findall(signature, response, flags=re.IGNORECASE)
                    if len(list_match) != 0:
                        # Add product name and version.
                        prod_info_list.append(product + str(items[1]) + ' ' + list_match[0])
        except Exception as err:
            self.util.print_message(WARNING, '{}'.format(err))
        return list(set(prod_info_list))

    # Classifier product name using signatures.
    def classifier_signature(self, target_info):
        product_list = []
        for target in target_info:
            for target_url in target[2]:
                # Get HTTP response (header + body).
                response = ''
                http = urllib3.PoolManager(timeout=self.util.http_timeout)
                try:
                    self.util.print_message(OK, 'Accessing: {}'.format(target_url))
                    res = http.request('GET', target_url)
                    for key in res.headers._container.keys():
                        response += key + ': ' + res.headers[key] + '\r\n'
                    response += '\r\n\r\n' + res.data.decode('utf-8')
                except Exception as err:
                    self.util.print_message(WARNING, '{}'.format(err))

                for category in ['os', 'web', 'framework', 'cms']:
                    prod_info = self.identify_product(category, response)
                    for product in prod_info:
                        parsed = util.parse_url(target_url)
                        product_list.append([product, parsed.scheme, parsed.port, parsed.path])

        return product_list
